#!/bin/bash
# gh-hooks - GitHub CLI extension for hook management
# This is the main entry point for the gh extension

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GH_HOOKS_VERSION="0.1.0"

# Source utility functions
# shellcheck source=lib/utils.sh
source "${SCRIPT_DIR}/lib/utils.sh"

# Help text
show_help() {
  cat <<EOF
gh hooks - Add hook functionality to GitHub CLI commands

USAGE
  gh hooks <command> [flags]

COMMANDS
  install [shell] [--force]  Install shell integration (add hooks to your shell)
                             Supported shells: bash, zsh, fish, nu
                             If not specified, auto-detects from \$SHELL
                             Use --force to reinstall
  uninstall                  Remove shell integration
  status                     Show hook status and configuration
  init [template]            Initialize .gh-hooks.sh in current project
                             Templates: rust, node
  enable                     Enable hooks execution
  disable                    Disable hooks execution
  help                       Show this help

EXAMPLES
  # Install shell integration (auto-detect shell)
  gh hooks install

  # Install for specific shell
  gh hooks install zsh
  gh hooks install fish

  # Force reinstall
  gh hooks install --force
  gh hooks install zsh --force

  # Initialize hooks in current project
  gh hooks init rust

  # Check hook status
  gh hooks status

  # Disable hooks temporarily
  gh hooks disable

VERSION
  ${GH_HOOKS_VERSION}

DOCUMENTATION
  https://github.com/shabaraba/gh-hooks
EOF
}

# Install shell integration
cmd_install() {
  local shell_type="auto"
  local force_install=0

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f)
        force_install=1
        shift
        ;;
      *)
        shell_type="$1"
        shift
        ;;
    esac
  done

  local shell_rc=""
  local shell_profile=""
  local source_command=""

  # Detect shell
  if [ "$shell_type" = "auto" ]; then
    local current_shell="$(basename "$SHELL")"
    case "$current_shell" in
      bash)
        shell_type="bash"
        ;;
      zsh)
        shell_type="zsh"
        ;;
      fish)
        shell_type="fish"
        ;;
      nu)
        shell_type="nu"
        ;;
      *)
        echo "Error: Could not detect shell type from SHELL=$SHELL"
        echo "Please specify one of: bash, zsh, fish, nu"
        exit 1
        ;;
    esac
  fi

  # Determine RC file, profile file, and source command
  case "$shell_type" in
    bash)
      # macOS uses .bash_profile, Linux uses .bashrc
      if [[ "$OSTYPE" == "darwin"* ]]; then
        shell_rc="${HOME}/.bashrc"
        shell_profile="${HOME}/.bash_profile"
      else
        shell_rc="${HOME}/.bashrc"
        shell_profile="${HOME}/.profile"
      fi
      source_command="source \"${SCRIPT_DIR}/gh-hooks.sh\""
      ;;
    zsh)
      shell_rc="${HOME}/.zshrc"
      shell_profile="${HOME}/.zprofile"
      source_command="source \"${SCRIPT_DIR}/gh-hooks.sh\""
      ;;
    fish)
      shell_rc="${HOME}/.config/fish/config.fish"
      # Fish doesn't have a separate profile file
      shell_profile=""
      # Fish uses different syntax
      source_command="source \"${SCRIPT_DIR}/gh-hooks.fish\""
      ;;
    nu)
      shell_rc="${HOME}/.config/nushell/config.nu"
      # Nushell doesn't have a separate profile file
      shell_profile=""
      # Nushell uses different syntax
      source_command="source \"${SCRIPT_DIR}/gh-hooks.nu\""
      ;;
    *)
      echo "Error: Unsupported shell: $shell_type"
      echo "Supported shells: bash, zsh, fish, nu"
      exit 1
      ;;
  esac

  # Helper function to install to a single file
  install_to_file() {
    local target_file="$1"
    local file_type="$2"  # "RC" or "profile"

    # Create config directory if it doesn't exist
    local config_dir="$(dirname "$target_file")"
    if [ ! -d "$config_dir" ]; then
      mkdir -p "$config_dir"
      echo "Created directory: $config_dir"
    fi

    # Create file if it doesn't exist
    # Check both file existence and if it's a broken symlink
    if [ ! -f "$target_file" ] && [ ! -L "$target_file" ]; then
      touch "$target_file"
      echo "Created $target_file"
    elif [ -L "$target_file" ] && [ ! -e "$target_file" ]; then
      echo "Warning: $target_file is a broken symlink"
      echo "Please fix the symlink or remove it before installing"
      return 1
    fi

    # Check if already installed
    if grep -q "gh-hooks" "$target_file" 2>/dev/null; then
      # Check if the path is correct
      local current_path
      current_path=$(grep "source.*gh-hooks" "$target_file" | sed 's/.*source[[:space:]]*["'"'"']\(.*\)["'"'"'].*/\1/' | head -1)

      if [ "$current_path" = "${SCRIPT_DIR}/gh-hooks.sh" ] && [ $force_install -eq 0 ]; then
        echo "✓ gh-hooks is already installed in $target_file"
        return 0
      fi

      if [ $force_install -eq 0 ]; then
        echo "⚠ gh-hooks is installed in $target_file but with a different path"
        echo "  Current: $current_path"
        echo "  New: ${SCRIPT_DIR}/gh-hooks.sh"
        echo ""
        read -p "Update to new path? [y/N] " -n 1 -r
        echo

        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
          echo "Installation cancelled"
          echo "To force reinstall, use: gh hooks install --force"
          return 1
        fi
      fi

      # Remove old entry
      echo "Removing old entry from $target_file..."

      # Resolve symlink if needed
      local actual_file="$target_file"
      if [ -L "$target_file" ]; then
        actual_file="$(readlink -f "$target_file" 2>/dev/null || readlink "$target_file")"
        echo "Note: $target_file is a symlink to $actual_file"
      fi

      if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        sed -i '' '/# gh-hooks: GitHub CLI hooks/d' "$actual_file"
        sed -i '' '/source.*gh-hooks/d' "$actual_file"
      else
        # Linux
        sed -i '/# gh-hooks: GitHub CLI hooks/d' "$actual_file"
        sed -i '/source.*gh-hooks/d' "$actual_file"
      fi

      echo "✓ Removed old entry from $target_file"
    fi

    # Add source line to file
    cat >> "$target_file" <<EOF

# gh-hooks: GitHub CLI hooks
${source_command}
EOF

    echo "✓ Installed to $target_file"
  }

  # Install to RC file
  install_to_file "$shell_rc" "RC" || return 1

  # Install to profile file if it exists for this shell
  if [ -n "$shell_profile" ]; then
    echo ""
    install_to_file "$shell_profile" "profile" || return 1
  fi

  echo ""
  echo "✓ gh-hooks installed successfully!"
  echo "  Shell: $shell_type"
  echo "  RC file: $shell_rc"
  if [ -n "$shell_profile" ]; then
    echo "  Profile file: $shell_profile"
  fi
  echo ""

  # Show shell-specific activation instructions
  case "$shell_type" in
    fish)
      echo "To activate, restart your shell or run:"
      echo "  exec fish"
      ;;
    nu)
      echo "To activate, restart your shell"
      ;;
    *)
      echo "To activate, run one of:"
      echo "  source $shell_rc"
      echo "  exec $SHELL"
      ;;
  esac

  echo ""
  echo "Then run 'gh hooks status' to verify installation."

  # Warn if shell-specific file doesn't exist
  case "$shell_type" in
    fish)
      if [ ! -f "${SCRIPT_DIR}/gh-hooks.fish" ]; then
        echo ""
        echo "⚠ Warning: ${SCRIPT_DIR}/gh-hooks.fish not found"
        echo "  Fish shell support will be added in a future version"
      fi
      ;;
    nu)
      if [ ! -f "${SCRIPT_DIR}/gh-hooks.nu" ]; then
        echo ""
        echo "⚠ Warning: ${SCRIPT_DIR}/gh-hooks.nu not found"
        echo "  Nushell support will be added in a future version"
      fi
      ;;
  esac
}

# Uninstall shell integration
cmd_uninstall() {
  local shell_rc_files=(
    "${HOME}/.bashrc"
    "${HOME}/.bash_profile"
    "${HOME}/.profile"
    "${HOME}/.zshrc"
    "${HOME}/.zprofile"
    "${HOME}/.config/fish/config.fish"
    "${HOME}/.config/nushell/config.nu"
  )

  local found=0

  for rc_file in "${shell_rc_files[@]}"; do
    if [ -f "$rc_file" ] && grep -q "gh-hooks" "$rc_file"; then
      # Resolve symlink if it is one
      local target_file="$rc_file"
      if [ -L "$rc_file" ]; then
        target_file="$(readlink -f "$rc_file" 2>/dev/null || readlink "$rc_file")"
        echo "Note: $rc_file is a symlink to $target_file"
      fi

      # Create backup
      cp "$target_file" "${target_file}.gh-hooks.backup"

      # Remove gh-hooks lines using a temporary file
      grep -v -e "# gh-hooks: GitHub CLI hooks" -e "source.*gh-hooks" "$target_file" > "${target_file}.tmp"
      mv "${target_file}.tmp" "$target_file"

      echo "✓ Removed gh-hooks from $rc_file"
      echo "  (Backup saved to ${target_file}.gh-hooks.backup)"
      found=1
    fi
  done

  if [ $found -eq 0 ]; then
    echo "gh-hooks is not installed in any RC file"
    return 1
  fi

  echo ""
  echo "To complete uninstallation, restart your shell or run:"
  echo "  exec \$SHELL"
}

# Show status
cmd_status() {
  echo "gh-hooks status"
  echo "==============="
  echo ""

  # Check if gh-hooks.sh is sourced in shell RC files
  local shell_rc_files=(
    "${HOME}/.bashrc"
    "${HOME}/.bash_profile"
    "${HOME}/.profile"
    "${HOME}/.zshrc"
    "${HOME}/.zprofile"
    "${HOME}/.config/fish/config.fish"
  )

  local installed=0
  local rc_files_found=()

  for rc_file in "${shell_rc_files[@]}"; do
    if [ -f "$rc_file" ] && grep -q "gh-hooks" "$rc_file" 2>/dev/null; then
      installed=1
      rc_files_found+=("$rc_file")
    fi
  done

  if [ $installed -eq 1 ]; then
    echo "✓ Shell integration: INSTALLED"
    for found_file in "${rc_files_found[@]}"; do
      echo "  Config file: $found_file"
    done
    echo "  Note: Use 'gh_hooks_status' function in your shell for live status"
  else
    echo "✗ Shell integration: NOT INSTALLED"
    echo "  Run 'gh hooks install' to set up"
    return 1
  fi

  echo ""

  # Check if in git repo
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "✗ Git repository: NOT FOUND"
    echo "  Not in a git repository"
    return 0
  fi

  echo "✓ Git repository: FOUND"

  # Find project root
  local project_root
  project_root=$(git rev-parse --show-toplevel 2>/dev/null)

  if [ -z "$project_root" ]; then
    echo "✗ Project root: NOT FOUND"
    return 1
  fi

  echo "  Root: $project_root"
  echo ""

  # Check for .gh-hooks.sh
  if [ -f "${project_root}/.gh-hooks.sh" ]; then
    echo "✓ Project configuration: FOUND"
    echo "  File: ${project_root}/.gh-hooks.sh"

    # List defined hooks
    echo ""
    echo "Defined hooks:"
    local hooks=(
      "gh_hook_pr_merged"
      "gh_hook_pr_created"
      "gh_hook_pr_closed"
      "gh_hook_release_created"
      "gh_hook_release_pr_merged"
    )

    # shellcheck source=/dev/null
    source "${project_root}/.gh-hooks.sh" 2>/dev/null || true

    for hook in "${hooks[@]}"; do
      if type "$hook" >/dev/null 2>&1; then
        echo "  ✓ $hook"
      else
        echo "  - $hook (not defined)"
      fi
    done
  else
    echo "✗ Project configuration: NOT FOUND"
    echo "  Run 'gh hooks init' to create .gh-hooks.sh"
  fi

  echo ""

  # Check environment
  echo "Environment:"
  echo "  GH_HOOKS_ENABLED=${GH_HOOKS_ENABLED:-1}"
  echo "  GH_HOOKS_DEBUG=${GH_HOOKS_DEBUG:-0}"

  if [ -n "$GITHUB_TOKEN" ]; then
    echo "  GITHUB_TOKEN=***set***"
  else
    echo "  GITHUB_TOKEN=(not set)"
  fi
}

# Initialize project configuration
cmd_init() {
  local template="${1:-rust}"
  local target_file=".gh-hooks.sh"

  if [ -f "$target_file" ]; then
    echo "Error: $target_file already exists"
    echo "Remove it first or edit it manually"
    exit 1
  fi

  local template_file=""
  case "$template" in
    rust)
      template_file="${SCRIPT_DIR}/examples/rust-crates.sh"
      ;;
    node|npm)
      template_file="${SCRIPT_DIR}/examples/npm-publish.sh"
      ;;
    *)
      echo "Error: Unknown template: $template"
      echo "Available templates: rust, node"
      exit 1
      ;;
  esac

  if [ ! -f "$template_file" ]; then
    echo "Error: Template file not found: $template_file"
    exit 1
  fi

  cp "$template_file" "$target_file"
  chmod +x "$target_file"

  echo "✓ Created $target_file from $template template"
  echo ""
  echo "Next steps:"
  echo "  1. Edit $target_file to customize hooks"
  echo "  2. Set GITHUB_TOKEN environment variable"
  echo "  3. Run 'gh pr merge' to test hooks"
}

# Enable hooks
cmd_enable() {
  echo "export GH_HOOKS_ENABLED=1" >> "${HOME}/.gh-hooks-config"
  echo "✓ Hooks enabled"
  echo "  Run 'exec \$SHELL' to reload"
}

# Disable hooks
cmd_disable() {
  echo "export GH_HOOKS_ENABLED=0" >> "${HOME}/.gh-hooks-config"
  echo "✓ Hooks disabled"
  echo "  Run 'exec \$SHELL' to reload"
}

# Main command dispatcher
main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    install)
      cmd_install "$@"
      ;;
    uninstall)
      cmd_uninstall "$@"
      ;;
    status)
      cmd_status "$@"
      ;;
    init)
      cmd_init "$@"
      ;;
    enable)
      cmd_enable "$@"
      ;;
    disable)
      cmd_disable "$@"
      ;;
    help|--help|-h)
      show_help
      ;;
    *)
      echo "Error: Unknown command: $cmd"
      echo ""
      show_help
      exit 1
      ;;
  esac
}

main "$@"
